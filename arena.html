<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Arena v13 â€“ Boss Update</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  html,body{margin:0;padding:0;background:#0a0511;overflow:hidden;font-family:monospace}
  canvas{width:100vw;height:100vh;display:block;image-rendering:pixelated}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
  addEventListener("resize", resize); resize();

  // ===== COLOR PALETTE =====
  const COLORS = {
    // Classes
    warrior: { primary: "#3cff6b", secondary: "#2acc50", accent: "#1a9939" },
    archer: { primary: "#44d9ff", secondary: "#2ab3d9", accent: "#1a8cb3" },
    wizard: { primary: "#b066ff", secondary: "#9044d9", accent: "#7033b3" },

    // Enemies - Enhanced palette
    grunt: { body: "#ff4444", dark: "#cc2222", glow: "#ff8888", elite: "#ff6666" },
    runner: { body: "#ffaa33", dark: "#cc8822", glow: "#ffcc77", elite: "#ffcc55" },
    shooter: { body: "#ff44d9", dark: "#cc22aa", glow: "#ff88ee", elite: "#ff66ee" },
    tank: { body: "#991111", dark: "#660000", glow: "#dd4444", elite: "#cc3333" },
    bomber: { body: "#44ff44", dark: "#22aa22", glow: "#88ff88", elite: "#66ff66" },
    charger: { body: "#4444ff", dark: "#2222aa", glow: "#8888ff", elite: "#6666ff" },
    sniper: { body: "#aa44ff", dark: "#7722aa", glow: "#dd88ff", elite: "#cc66ff" },
    summoner: { body: "#ffff44", dark: "#aaaa22", glow: "#ffff88", elite: "#ffff66" },
    boss: { body: "#ff0000", dark: "#aa0000", glow: "#ff4444", elite: "#ff2222" },
    miniboss: { body: "#ff8800", dark: "#aa5500", glow: "#ffaa44", elite: "#ffaa22" },

    // UI
    ui: {
      bg: "#0a0511",
      bgOverlay: "#000000",
      panel: "#1a1a2e",
      border: "#2a2a44",
      borderActive: "#00ff88",
      text: "#e0e0ff",
      textDim: "#9999cc",
      textBright: "#ffffff",
      health: "#00ff44",
      healthLow: "#ff3333",
      healthBg: "#222244",
      gold: "#ffd700",
      success: "#00ff88",
      warning: "#ff8844",
      danger: "#ff4444",
      elite: "#ffaa00",
      boss: "#ff0000"
    }
  };

  // ===== ENEMY DEFINITIONS ===== (HARDCORE DIFFICULTY)
  const ENEMY_TYPES = {
    GRUNT: {
      hp: 3, speed: 0.24, attackRange: 220, attackDamage: 8, attackCD: 40,
      windupTime: 10, score: 18, size: 1.0,
      desc: "Aggressive melee fighter"
    },
    RUNNER: {
      hp: 4, speed: 0.32, attackRange: 380, attackDamage: 6, attackCD: 45,
      windupTime: 8, score: 28, size: 0.9,
      desc: "Lightning-fast attacker"
    },
    SHOOTER: {
      hp: 6, speed: 0.26, attackRange: 600, attackDamage: 10, attackCD: 40,
      windupTime: 15, score: 40, size: 1.0,
      desc: "Rapid-fire ranged enemy"
    },
    TANK: {
      hp: 12, speed: 0.16, attackRange: 260, attackDamage: 15, attackCD: 55,
      windupTime: 18, score: 55, size: 1.3,
      desc: "Relentless heavy hitter"
    },
    BOMBER: {
      hp: 5, speed: 0.28, attackRange: 180, attackDamage: 20, attackCD: 999,
      windupTime: 25, score: 50, size: 0.95,
      desc: "Suicide bomber - massive damage"
    },
    CHARGER: {
      hp: 8, speed: 0.18, attackRange: 500, attackDamage: 12, attackCD: 50,
      windupTime: 20, score: 45, size: 1.1,
      desc: "Bull rush attacks"
    },
    SNIPER: {
      hp: 5, speed: 0.14, attackRange: 750, attackDamage: 18, attackCD: 60,
      windupTime: 30, score: 60, size: 0.95,
      desc: "Deadly precision shots"
    },
    SUMMONER: {
      hp: 10, speed: 0.12, attackRange: 550, attackDamage: 0, attackCD: 80,
      windupTime: 35, score: 70, size: 1.15,
      desc: "Spawns reinforcements"
    },
    MINIBOSS: {
      hp: 80, speed: 0.16, attackRange: 400, attackDamage: 18, attackCD: 35,
      windupTime: 15, score: 200, size: 1.8,
      desc: "Powerful elite with multi-attacks"
    },
    BOSS: {
      hp: 200, speed: 0.14, attackRange: 450, attackDamage: 22, attackCD: 30,
      windupTime: 20, score: 500, size: 2.5,
      desc: "Ultimate challenge - attack patterns"
    }
  };

  // INPUT
  const keys = Object.create(null);
  const just = Object.create(null);
  addEventListener("keydown", (e) => {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    if (!keys[e.key]) just[e.key] = true;
    keys[e.key] = true;
  }, {passive:false});
  addEventListener("keyup", (e) => keys[e.key] = false);
  const use = (k) => { const v = !!just[k]; just[k] = false; return v; };

  // RNG (seeded)
  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function hashSeed(str){
    let h = 2166136261 >>> 0;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  // STATE
  const STATE = { MENU:0, PLAY:1, UPGRADE:2, OVER:3 };
  let state = STATE.MENU;

  // WORLD
  const WORLD = { w: 1400, h: 900 };
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist = (ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);

  // CLASSES
  const CLASSES = [
    {name:"WARRIOR", hp:160, speed:3.2, accel:0.35, drag:0.86, cd:12, desc:"High HP, melee cleave attacks"},
    {name:"ARCHER",  hp:125, speed:3.6, accel:0.38, drag:0.86, cd:16, desc:"Ranged piercing arrows"},
    {name:"WIZARD",  hp:110, speed:3.1, accel:0.34, drag:0.86, cd:14, desc:"Glass cannon - magic orb volleys"},
  ];
  let pick = 0;

  // ITEMS
  const ITEM_POOL = [
    {id:"hp_up",     name:"+MAX HP",      desc:"+20 max HP and heal 20",              icon:"â™¥", rarity:"common",   apply:(g)=>{g.player.max += 20; g.player.hp += 20;}},
    {id:"spd_up",    name:"+SPEED",       desc:"+8% movement speed",                  icon:"âš¡", rarity:"common",   apply:(g)=>{g.player.speed *= 1.08;}},
    {id:"cd_down",   name:"FASTER ATK",   desc:"-10% attack cooldown",                icon:"âš”", rarity:"common",   apply:(g)=>{g.player.cd = Math.max(6, Math.floor(g.player.cd * 0.90));}},
    {id:"heal_on",   name:"ROOM HEAL",    desc:"Heal 18 HP on room clear",            icon:"âœš", rarity:"rare",     apply:(g)=>{g.mods.healOnClear += 18;}},
    {id:"resist",    name:"TOUGH SKIN",   desc:"-10% touch damage taken",             icon:"â—ˆ", rarity:"rare",     apply:(g)=>{g.mods.touchResist *= 0.90;}},
    {id:"cleave_w",  name:"WIDE CLEAVE",  desc:"(Warrior) +25% cleave width",         icon:"â†”", rarity:"epic",     apply:(g)=>{g.mods.cleaveArc *= 1.25;}},
    {id:"pierce",    name:"PIERCE ARROW", desc:"(Archer) +1 arrow pierce",            icon:"âž¤", rarity:"epic",     apply:(g)=>{g.mods.arrowPierce += 1;}},
    {id:"burst_r",   name:"MAGIC MASTERY", desc:"(Wizard) +1 orb, +10% size",          icon:"â—‰", rarity:"epic",     apply:(g)=>{g.mods.orbCount += 1; g.mods.orbSize *= 1.10;}},
    {id:"knock",     name:"HEAVY HITS",   desc:"+25% knockback on all attacks",       icon:"ðŸ’¥", rarity:"rare",     apply:(g)=>{g.mods.knock *= 1.25;}},
    {id:"crit",      name:"SHARP EDGE",   desc:"10% chance to deal double damage",    icon:"â˜…", rarity:"epic",     apply:(g)=>{g.mods.critChance += 0.10;}},
  ];

  // GAME container
  const G = {
    rng: mulberry32(1),
    seedStr: "0",
    seedU32: 1,
    player: null,
    enemies: [],
    pShots: [],
    eShots: [],
    portals: [],
    particles: [],
    damageNumbers: [],
    tick: 0,
    score: 0,
    kills: 0,
    hitstop: 0,
    shake: 0,
    room: 1,
    phase: "ENTER",
    phaseT: 0,
    wave: 0,
    toSpawn: 0,
    maxOnScreen: 6,
    upgradeChoices: [],
    upgradesTaken: [],
    displayHP: 0,
    targetHP: 0,
    bossHP: 0,
    bossMaxHP: 0,
    bossName: "",
    isBossRoom: false,
    mods: {
      touchResist: 1.0,
      healOnClear: 0,
      cleaveArc: 1.0,
      arrowPierce: 0,
      orbCount: 0,
      orbSize: 1.0,
      knock: 1.0,
      critChance: 0.0
    }
  };
  function rnd(){ return G.rng(); }
  function rndi(n){ return (rnd()*n)|0; }
  function choice(arr){ return arr[rndi(arr.length)]; }

  // ===== PARTICLE SYSTEM =====
  function addParticle(x, y, vx, vy, color, size, life){
    G.particles.push({x, y, vx, vy, color, size, life, maxLife: life, gravity: 0});
  }

  function addExplosion(x, y, color, count=12){
    for(let i=0; i<count; i++){
      const angle = (i / count) * Math.PI * 2;
      const speed = 2 + rnd() * 3;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      const size = 4 + rnd() * 6;
      const life = 20 + rndi(15);
      addParticle(x, y, vx, vy, color, size, life);
    }
  }

  function addBloodSpray(x, y, dx, dy){
    for(let i=0; i<8; i++){
      const spread = 0.5;
      const vx = dx * 0.3 + (rnd() - 0.5) * spread;
      const vy = dy * 0.3 + (rnd() - 0.5) * spread;
      const size = 3 + rnd() * 4;
      const life = 15 + rndi(10);
      addParticle(x, y, vx, vy, "#ff3333", size, life);
    }
  }

  function updateParticles(){
    for(const p of G.particles){
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.95;
      p.vy *= 0.95;
      p.vy += p.gravity;
      p.life--;
    }
    G.particles = G.particles.filter(p => p.life > 0);
  }

  function drawParticles(){
    for(const p of G.particles){
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha * 0.8;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    }
    ctx.globalAlpha = 1;
  }

  // ===== DAMAGE NUMBERS =====
  function addDamageNumber(x, y, amount, isCrit=false){
    G.damageNumbers.push({
      x, y: y - 40,
      amount,
      isCrit,
      life: 60,
      vy: -1.2
    });
  }

  function updateDamageNumbers(){
    for(const dn of G.damageNumbers){
      dn.y += dn.vy;
      dn.vy += 0.05;
      dn.life--;
    }
    G.damageNumbers = G.damageNumbers.filter(dn => dn.life > 0);
  }

  function drawDamageNumbers(){
    ctx.save();
    ctx.font = "bold 18px monospace";
    for(const dn of G.damageNumbers){
      const alpha = Math.min(1, dn.life / 30);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = dn.isCrit ? COLORS.ui.gold : COLORS.ui.warning;
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 3;
      const text = dn.isCrit ? `${dn.amount}!` : `${dn.amount}`;
      ctx.strokeText(text, dn.x, dn.y);
      ctx.fillText(text, dn.x, dn.y);
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function setupPortals(){
    G.portals.length = 0;
    G.portals.push({x: WORLD.w*0.5, y: 80, t:0});
    G.portals.push({x: WORLD.w*0.5, y: WORLD.h-80, t:0});
    G.portals.push({x: 80, y: WORLD.h*0.5, t:0});
    G.portals.push({x: WORLD.w-80, y: WORLD.h*0.5, t:0});
    G.portals.push({x: 140, y: 140, t:0});
    G.portals.push({x: WORLD.w-140, y: 140, t:0});
  }

  function resetRun(cls, seedStr){
    G.seedStr = seedStr;
    G.seedU32 = hashSeed(seedStr);
    G.rng = mulberry32(G.seedU32);

    G.player = {
      name: cls.name,
      x: WORLD.w/2, y: WORLD.h/2,
      vx: 0, vy: 0,
      hp: cls.hp, max: cls.hp,
      speed: cls.speed, accel: cls.accel, drag: cls.drag,
      cd: cls.cd, cdT: 0,
      facing: 1,
      aimX: 1, aimY: 0,
      step: 0,
      atkT: 0,
      hurtT: 0
    };

    G.enemies.length = 0;
    G.pShots.length = 0;
    G.eShots.length = 0;
    G.particles.length = 0;
    G.damageNumbers.length = 0;
    G.tick = 0;
    G.score = 0;
    G.kills = 0;
    G.hitstop = 0;
    G.shake = 0;
    G.displayHP = cls.hp;
    G.targetHP = cls.hp;
    G.bossHP = 0;
    G.bossMaxHP = 0;
    G.bossName = "";
    G.isBossRoom = false;

    G.room = 1;
    G.phase = "ENTER";
    G.phaseT = 25;
    G.wave = 0;
    G.toSpawn = 0;
    G.maxOnScreen = 6;

    G.upgradeChoices = [];
    G.upgradesTaken = [];

    G.mods = {
      touchResist: 1.0,
      healOnClear: 0,
      cleaveArc: 1.0,
      arrowPierce: 0,
      orbCount: 0,
      orbSize: 1.0,
      knock: 1.0,
      critChance: 0.0
    };

    setupPortals();
    G._healedThisRoom = false;
  }

  // DRAW HELPERS
  function px(x,y,w,h,c,a=1){ ctx.globalAlpha=a; ctx.fillStyle=c; ctx.fillRect(x,y,w,h); ctx.globalAlpha=1; }
  function drawShadow(x,y,w){ ctx.globalAlpha=0.30; px(x-w/2, y+34, w, 10, "#000"); ctx.globalAlpha=1; }

  function drawHero(p){
    const S=6;
    drawShadow(p.x,p.y,64);
    const bob=Math.sin(p.step/5)*2;
    const x=p.x,y=p.y+bob;
    const step=(p.step%10)<5?-1:1;
    const colorScheme = (p.name==="WARRIOR") ? COLORS.warrior : (p.name==="ARCHER") ? COLORS.archer : COLORS.wizard;
    const atk=p.atkT>0;
    const dirAng=Math.atan2(p.aimY, p.aimX);

    if(p.name==="WARRIOR"){
      // WARRIOR - Armored Knight
      // Legs (armored)
      px(x-2.5*S,y+2*S,2.5*S,4*S,"#4a4a4a");
      px(x+0*S,y+2*S,2.5*S,4*S,"#4a4a4a");
      px(x-2.5*S,y+2*S+step,2.5*S,4*S,"#5a5a5a");
      px(x+0*S,y+2*S-step,2.5*S,4*S,"#5a5a5a");

      // Armored body (broader)
      px(x-4*S,y-1*S,8*S,5*S, colorScheme.primary);
      px(x-4*S,y-1*S,8*S,2*S, colorScheme.secondary, 0.7);

      // Armor plates
      px(x-3*S,y+1*S,2*S,2*S,"#7a7a7a", 0.8);
      px(x+1*S,y+1*S,2*S,2*S,"#7a7a7a", 0.8);

      // Helmet
      px(x-2.5*S,y-4*S,5*S,3*S,"#6a6a6a");
      px(x-1.5*S,y-3.5*S,3*S,1.5*S,"#3a3a3a", 0.6); // Visor
      px(x-0.5*S,y-5*S,1*S,1*S,"#8a8a8a"); // Helmet spike

      // Shield on back
      px(x-5*S,y-1*S,1.5*S,5*S,"#9aa4ad");
      px(x-5*S,y,1.5*S,2*S, colorScheme.accent, 0.7);

      // Sword
      if(atk){
        const ax = Math.cos(dirAng)*5*S;
        const ay = Math.sin(dirAng)*5*S;
        px(x+ax-S, y+ay-3*S, 2*S, 6*S, "#e6edf3");
        px(x+ax-1.5*S, y+ay-4*S, 3*S, 1*S, "#9a9a9a");
        ctx.globalAlpha = 0.5;
        px(x+ax, y+ay-2*S, 1*S, 5*S, colorScheme.primary);
        ctx.globalAlpha = 1;
      } else {
        px(x+4*S,y-1*S,1.5*S,5*S,"#c6c6c6", 0.9);
        px(x+3.5*S,y-2*S,2*S,1*S,"#8a8a8a", 0.9);
      }

    } else if(p.name==="ARCHER"){
      // ARCHER - Hooded Ranger
      // Legs (light armor)
      px(x-2*S,y+2*S,2*S,4*S,"#3a5a3a");
      px(x+0*S,y+2*S,2*S,4*S,"#3a5a3a");
      px(x-2*S,y+2*S+step,2*S,4*S,"#4a6a4a");
      px(x+0*S,y+2*S-step,2*S,4*S,"#4a6a4a");

      // Body (lean)
      px(x-3*S,y-0.5*S,6*S,4*S, colorScheme.primary);
      px(x-3*S,y-0.5*S,6*S,1.5*S, colorScheme.secondary, 0.6);

      // Quiver on back
      px(x-4*S,y-2*S,1.5*S,4*S,"#5a3a1a");
      px(x-4*S,y-2*S,1.5*S,0.5*S,"#8a6a4a");
      // Arrows in quiver
      px(x-3.5*S,y-3*S,0.5*S,1*S,"#e6edf3");
      px(x-3.8*S,y-2.5*S,0.5*S,1*S,"#e6edf3");

      // Hood
      px(x-3*S,y-4*S,6*S,3*S, colorScheme.accent);
      px(x-2.5*S,y-4*S,5*S,2.5*S, colorScheme.primary, 0.8);
      px(x-1.5*S,y-3*S,3*S,1.5*S,"#d7d7d7"); // Face

      // Bow
      if(atk){
        const ax = Math.cos(dirAng)*4*S;
        const ay = Math.sin(dirAng)*4*S;
        px(x+ax-1*S, y+ay-3*S, 0.8*S, 7*S, "#8a6a4a");
        px(x+ax+0.5*S, y+ay-3*S, 0.8*S, 7*S, "#8a6a4a");
        px(x+ax-0.5*S, y+ay, 2*S, 0.5*S, "#e6edf3", 0.6);
      } else {
        px(x+4*S,y-2*S,0.8*S,6*S,"#8a6a4a", 0.9);
        px(x+4.8*S,y-2*S,0.8*S,6*S,"#8a6a4a", 0.9);
      }

    } else {
      // WIZARD - Mystical Mage
      // Legs (robed)
      px(x-3*S,y+2*S,6*S,4*S, colorScheme.accent);
      px(x-2.5*S,y+2*S,5*S,4*S, colorScheme.primary, 0.8);

      // Flowing robes
      px(x-3.5*S,y-1*S,7*S,5*S, colorScheme.primary);
      px(x-3.5*S,y-1*S,7*S,2*S, colorScheme.secondary, 0.7);

      // Robe trim
      px(x-3.5*S,y+3*S,7*S,0.8*S, colorScheme.secondary);
      px(x-3*S,y-1*S,1*S,5*S, colorScheme.secondary, 0.8);
      px(x+2*S,y-1*S,1*S,5*S, colorScheme.secondary, 0.8);

      // Wizard hat
      px(x-2*S,y-3.5*S,4*S,2*S, colorScheme.primary);
      px(x-1.5*S,y-6*S,3*S,2.5*S, colorScheme.accent);
      px(x-1*S,y-7*S,2*S,1*S, colorScheme.primary);
      px(x-2*S,y-3.5*S,4*S,0.6*S, colorScheme.secondary);

      // Face under hat
      px(x-1.5*S,y-3*S,3*S,1.5*S,"#d7d7d7");

      // Mystical orbs floating around
      const orbPulse = 0.5 + 0.5*Math.sin(G.tick/8);
      for(let i=0; i<3; i++){
        const angle = (G.tick/30) + (i*Math.PI*2/3);
        const orbX = x + Math.cos(angle)*4*S;
        const orbY = y-S + Math.sin(angle)*2*S;
        ctx.globalAlpha = 0.6*orbPulse;
        px(orbX-1, orbY-1, 2, 2, colorScheme.primary);
        ctx.shadowBlur = 4;
        ctx.shadowColor = colorScheme.primary;
        px(orbX-0.5, orbY-0.5, 1, 1, colorScheme.secondary);
        ctx.shadowBlur = 0;
      }
      ctx.globalAlpha = 1;

      // Staff
      if(atk){
        const ax = Math.cos(dirAng)*4*S;
        const ay = Math.sin(dirAng)*4*S;
        px(x+ax-0.5*S, y+ay-4*S, 1*S, 9*S, "#8a6a4a");
        px(x+ax-1*S, y+ay-5*S, 2*S, 2*S, colorScheme.primary);
        ctx.globalAlpha = 0.7;
        px(x+ax-1.5*S, y+ay-5.5*S, 3*S, 3*S, colorScheme.secondary);
        ctx.globalAlpha = 1;
      } else {
        px(x+4*S,y-3*S,1*S,9*S,"#8a6a4a", 0.9);
        px(x+3.5*S,y-4*S,2*S,2*S, colorScheme.primary, 0.9);
        ctx.globalAlpha = 0.5;
        px(x+3*S,y-4.5*S,3*S,3*S, colorScheme.secondary);
        ctx.globalAlpha = 1;
      }
    }
  }

  function drawEnemy(e){
    const S=6;
    const bob=Math.sin((G.tick+e.seed)/7)*2;
    const x=e.x, y=e.y+bob;
    const colorScheme = COLORS[e.role.toLowerCase()] || COLORS.grunt;
    const bodyColor = e.isElite ? colorScheme.elite : colorScheme.body;
    const step=((G.tick+e.seed)%10)<5?-1:1;
    const sizeM = e.size * (e.isElite ? 1.3 : 1.0);

    // Death animation wrapper
    if(e.dying){
      ctx.save();
      ctx.globalAlpha = e.deathT / 20;
      const scale = 1 + (1 - e.deathT / 20) * 0.5;
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      ctx.translate(-x, -y);
    }

    drawShadow(e.x, e.y, 58 * sizeM);

    // Elite glow ring
    if(e.isElite && !e.dying){
      const pulse = 0.5 + 0.5 * Math.sin(G.tick / 10);
      ctx.globalAlpha = 0.3 * pulse;
      ctx.strokeStyle = COLORS.ui.elite;
      ctx.lineWidth = 3;
      const radius = 40 * sizeM;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = e.dying ? (e.deathT / 20) : 1;
    }

    // Boss crown/indicator
    if(e.role === "BOSS" || e.role === "MINIBOSS"){
      const crownY = y - 50 * sizeM;
      ctx.fillStyle = e.role === "BOSS" ? COLORS.ui.boss : COLORS.ui.elite;
      ctx.font = `${Math.floor(20 * sizeM)}px monospace`;
      ctx.textAlign = "center";
      ctx.fillText(e.role === "BOSS" ? "ðŸ‘‘" : "âš¡", x, crownY);
      ctx.textAlign = "left";
    }

    // Draw based on enemy type
    if(e.role === "GRUNT"){
      // GRUNT - Small Goblin
      px(x-2*S*sizeM,y+2*S*sizeM,1.8*S*sizeM,3.5*S*sizeM,bodyColor);
      px(x+0.2*S*sizeM,y+2*S*sizeM,1.8*S*sizeM,3.5*S*sizeM,bodyColor);
      px(x-2.5*S*sizeM,y-0.5*S*sizeM,5*S*sizeM,3.5*S*sizeM,bodyColor);
      px(x-2.5*S*sizeM,y-0.5*S*sizeM,5*S*sizeM,1.5*S*sizeM,colorScheme.glow,0.4);
      px(x-2*S*sizeM,y-2.5*S*sizeM,4*S*sizeM,2*S*sizeM,colorScheme.dark);
      px(x-2.5*S*sizeM,y-3*S*sizeM,1.5*S*sizeM,1.5*S*sizeM,colorScheme.dark);
      px(x+1*S*sizeM,y-3*S*sizeM,1.5*S*sizeM,1.5*S*sizeM,colorScheme.dark);
      px(x-1*S*sizeM,y-2*S*sizeM,0.8*S*sizeM,0.8*S*sizeM,"#ff0",0.9);
      px(x+0.2*S*sizeM,y-2*S*sizeM,0.8*S*sizeM,0.8*S*sizeM,"#ff0",0.9);

    } else if(e.role === "RUNNER"){
      // RUNNER - Wolf-like Beast
      px(x-3*S*sizeM,y+1*S*sizeM,2*S*sizeM,2.5*S*sizeM,bodyColor);
      px(x+1*S*sizeM,y+1*S*sizeM,2*S*sizeM,2.5*S*sizeM,bodyColor);
      px(x-4*S*sizeM,y-0.5*S*sizeM,8*S*sizeM,3*S*sizeM,bodyColor);
      px(x-4*S*sizeM,y-0.5*S*sizeM,8*S*sizeM,1.2*S*sizeM,colorScheme.glow,0.5);
      px(x+2*S*sizeM,y-2*S*sizeM,3*S*sizeM,2.5*S*sizeM,colorScheme.dark);
      px(x+3*S*sizeM,y-3*S*sizeM,1*S*sizeM,1*S*sizeM,colorScheme.dark);
      px(x+3*S*sizeM,y-3.5*S*sizeM,1*S*sizeM,1*S*sizeM,colorScheme.dark);
      px(x+4*S*sizeM,y-2.2*S*sizeM,1.5*S*sizeM,0.6*S*sizeM,"#f00",0.8);

    } else if(e.role === "SHOOTER"){
      // SHOOTER - Skeleton Archer
      px(x-2*S*sizeM,y+2*S*sizeM,1.5*S*sizeM,4*S*sizeM,"#9a9a9a");
      px(x+0.5*S*sizeM,y+2*S*sizeM,1.5*S*sizeM,4*S*sizeM,"#9a9a9a");
      px(x-2*S*sizeM,y-0.5*S*sizeM,4*S*sizeM,3*S*sizeM,bodyColor);
      px(x-2.5*S*sizeM,y-2.5*S*sizeM,5*S*sizeM,2.5*S*sizeM,"#e6e6e6");
      px(x-1.5*S*sizeM,y-2*S*sizeM,1.5*S*sizeM,1.5*S*sizeM,"#000",0.9);
      px(x+0*S*sizeM,y-2*S*sizeM,1.5*S*sizeM,1.5*S*sizeM,"#000",0.9);
      px(x+2*S*sizeM,y,0.6*S*sizeM,4*S*sizeM,"#8a6a4a",0.8);
      px(x+3*S*sizeM,y,0.6*S*sizeM,4*S*sizeM,"#8a6a4a",0.8);

    } else if(e.role === "TANK"){
      // TANK - Massive Ogre
      px(x-3*S*sizeM,y+1.5*S*sizeM,2.5*S*sizeM,4.5*S*sizeM,bodyColor);
      px(x+0.5*S*sizeM,y+1.5*S*sizeM,2.5*S*sizeM,4.5*S*sizeM,bodyColor);
      px(x-4.5*S*sizeM,y-1*S*sizeM,9*S*sizeM,5*S*sizeM,bodyColor);
      px(x-4.5*S*sizeM,y-1*S*sizeM,9*S*sizeM,2*S*sizeM,colorScheme.dark,0.6);
      px(x-3*S*sizeM,y+1*S*sizeM,2*S*sizeM,2*S*sizeM,colorScheme.dark,0.8);
      px(x+1*S*sizeM,y+1*S*sizeM,2*S*sizeM,2*S*sizeM,colorScheme.dark,0.8);
      px(x-3.5*S*sizeM,y-3.5*S*sizeM,7*S*sizeM,3*S*sizeM,colorScheme.dark);
      px(x-4*S*sizeM,y-4.5*S*sizeM,1.5*S*sizeM,2*S*sizeM,colorScheme.dark);
      px(x+2.5*S*sizeM,y-4.5*S*sizeM,1.5*S*sizeM,2*S*sizeM,colorScheme.dark);
      px(x-1.5*S*sizeM,y-2.5*S*sizeM,1*S*sizeM,1*S*sizeM,"#f00",0.9);
      px(x+0.5*S*sizeM,y-2.5*S*sizeM,1*S*sizeM,1*S*sizeM,"#f00",0.9);

    } else if(e.role === "BOMBER"){
      // BOMBER - Round Bomb Creature
      px(x-3*S*sizeM,y,6*S*sizeM,4*S*sizeM,bodyColor);
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(x,y+S*sizeM,3.5*S*sizeM,0,Math.PI*2);
      ctx.fillStyle = bodyColor;
      ctx.fill();
      ctx.globalAlpha = 1;
      px(x-1.5*S*sizeM,y-1*S*sizeM,3*S*sizeM,2*S*sizeM,colorScheme.dark);
      px(x-1*S*sizeM,y-0.5*S*sizeM,0.8*S*sizeM,0.8*S*sizeM,"#000",0.8);
      px(x+0.2*S*sizeM,y-0.5*S*sizeM,0.8*S*sizeM,0.8*S*sizeM,"#000",0.8);
      const fuseGlow = 0.5 + 0.5 * Math.sin(G.tick / 5);
      ctx.globalAlpha = fuseGlow;
      px(x-0.5*S*sizeM,y-3*S*sizeM,1*S*sizeM,2.5*S*sizeM,"#222");
      px(x-S*sizeM,y-4*S*sizeM,2*S*sizeM,1.5*S*sizeM,"#ff4444");
      ctx.globalAlpha = 1;

    } else if(e.role === "CHARGER"){
      // CHARGER - Bull-like
      px(x-3.5*S*sizeM,y+1*S*sizeM,2.5*S*sizeM,3*S*sizeM,bodyColor);
      px(x+1*S*sizeM,y+1*S*sizeM,2.5*S*sizeM,3*S*sizeM,bodyColor);
      px(x-4*S*sizeM,y-1*S*sizeM,8*S*sizeM,4*S*sizeM,bodyColor);
      px(x-4*S*sizeM,y-1*S*sizeM,8*S*sizeM,1.5*S*sizeM,colorScheme.dark,0.5);
      px(x+1.5*S*sizeM,y-2.5*S*sizeM,4*S*sizeM,3*S*sizeM,colorScheme.dark);
      px(x+2*S*sizeM,y-4*S*sizeM,1.2*S*sizeM,2*S*sizeM,"#888",0.9);
      px(x+4*S*sizeM,y-4*S*sizeM,1.2*S*sizeM,2*S*sizeM,"#888",0.9);
      px(x+3*S*sizeM,y-2*S*sizeM,1.5*S*sizeM,1*S*sizeM,"#f00",0.8);

    } else if(e.role === "SNIPER"){
      // SNIPER - Tall Hooded Figure
      px(x-2*S*sizeM,y+1*S*sizeM,4*S*sizeM,5*S*sizeM,bodyColor);
      px(x-2.5*S*sizeM,y-1*S*sizeM,5*S*sizeM,4*S*sizeM,bodyColor);
      px(x-2.5*S*sizeM,y-1*S*sizeM,5*S*sizeM,1.5*S*sizeM,colorScheme.glow,0.5);
      px(x-2.5*S*sizeM,y-4*S*sizeM,5*S*sizeM,3.5*S*sizeM,colorScheme.dark);
      px(x-1.5*S*sizeM,y-5.5*S*sizeM,3*S*sizeM,2*S*sizeM,colorScheme.dark);
      px(x-0.8*S*sizeM,y-3*S*sizeM,1.5*S*sizeM,0.5*S*sizeM,"#a0a",0.9);
      px(x+3*S*sizeM,y-2*S*sizeM,0.8*S*sizeM,6*S*sizeM,"#666",0.8);

    } else if(e.role === "SUMMONER"){
      // SUMMONER - Necromancer
      px(x-3*S*sizeM,y+1.5*S*sizeM,6*S*sizeM,4.5*S*sizeM,bodyColor);
      px(x-3.5*S*sizeM,y-0.5*S*sizeM,7*S*sizeM,4*S*sizeM,bodyColor);
      px(x-3.5*S*sizeM,y-0.5*S*sizeM,7*S*sizeM,1.5*S*sizeM,colorScheme.glow,0.5);
      px(x-3.5*S*sizeM,y+3*S*sizeM,7*S*sizeM,0.8*S*sizeM,colorScheme.dark);
      px(x-2.5*S*sizeM,y-3.5*S*sizeM,5*S*sizeM,3.5*S*sizeM,colorScheme.dark);
      px(x-1*S*sizeM,y-2.5*S*sizeM,2*S*sizeM,1.5*S*sizeM,"#222");
      px(x+4*S*sizeM,y-2*S*sizeM,1*S*sizeM,7*S*sizeM,"#5a3a1a",0.8);
      px(x+3.5*S*sizeM,y-3*S*sizeM,2*S*sizeM,2*S*sizeM,"#ff0",0.7);
      for(let i=0; i<3; i++){
        const angle = (G.tick / 20) + (i * Math.PI * 2 / 3);
        const orbX = x + Math.cos(angle) * 25 * sizeM;
        const orbY = y + Math.sin(angle) * 15 * sizeM;
        ctx.globalAlpha = 0.6;
        px(orbX - 2, orbY - 2, 4, 4, "#ffff88");
      }
      ctx.globalAlpha = 1;

    } else if(e.role === "BOSS" || e.role === "MINIBOSS"){
      // BOSS/MINIBOSS - Demon Lord
      px(x-4*S*sizeM,y+0.5*S*sizeM,3*S*sizeM,5*S*sizeM,bodyColor);
      px(x+1*S*sizeM,y+0.5*S*sizeM,3*S*sizeM,5*S*sizeM,bodyColor);
      px(x-5*S*sizeM,y-2*S*sizeM,10*S*sizeM,6*S*sizeM,bodyColor);
      px(x-5*S*sizeM,y-2*S*sizeM,10*S*sizeM,2.5*S*sizeM,colorScheme.dark,0.6);
      px(x-4*S*sizeM,y+0.5*S*sizeM,2.5*S*sizeM,3*S*sizeM,colorScheme.dark,0.8);
      px(x+1.5*S*sizeM,y+0.5*S*sizeM,2.5*S*sizeM,3*S*sizeM,colorScheme.dark,0.8);
      px(x-4.5*S*sizeM,y-5*S*sizeM,9*S*sizeM,4*S*sizeM,colorScheme.dark);
      px(x-5.5*S*sizeM,y-7*S*sizeM,2*S*sizeM,3*S*sizeM,colorScheme.dark);
      px(x+3.5*S*sizeM,y-7*S*sizeM,2*S*sizeM,3*S*sizeM,colorScheme.dark);
      px(x-2*S*sizeM,y-4*S*sizeM,1.5*S*sizeM,2*S*sizeM,"#ff0",0.9);
      px(x+0.5*S*sizeM,y-4*S*sizeM,1.5*S*sizeM,2*S*sizeM,"#ff0",0.9);
      px(x-5*S*sizeM,y-6*S*sizeM,2*S*sizeM,3*S*sizeM,"#888",0.7);
      px(x+3*S*sizeM,y-6*S*sizeM,2*S*sizeM,3*S*sizeM,"#888",0.7);
      const wingPulse = Math.sin(G.tick/10)*0.2;
      ctx.globalAlpha = 0.4 + wingPulse;
      px(x-7*S*sizeM,y-1*S*sizeM,2*S*sizeM,5*S*sizeM,colorScheme.glow);
      px(x+5*S*sizeM,y-1*S*sizeM,2*S*sizeM,5*S*sizeM,colorScheme.glow);
      ctx.globalAlpha = 1;

    } else {
      // Fallback default
      px(x-2*S*sizeM,y+2*S*sizeM,2*S*sizeM,4*S*sizeM,bodyColor);
      px(x+0*S*sizeM,y+2*S*sizeM,2*S*sizeM,4*S*sizeM,bodyColor);
      px(x-3*S*sizeM,y-1*S*sizeM,6*S*sizeM,4*S*sizeM,bodyColor);
      px(x-2*S*sizeM,y-3*S*sizeM,4*S*sizeM,2*S*sizeM,colorScheme.dark);
    }

    // Attack telegraph
    if(e.state==="WINDUP"){
      const telegraphColor = e.role === "SHOOTER" ? "#ff88ee" :
                             e.role === "SNIPER" ? "#dd88ff" :
                             e.role === "CHARGER" ? "#8888ff" : "#ffaa44";
      const alpha = e.dying ? (e.deathT / 20) * 0.35 : 0.35;
      ctx.globalAlpha = alpha;

      if(e.role === "SHOOTER" || e.role === "SNIPER"){
        const p = G.player;
        const dx = p.x - e.x, dy = p.y - e.y;
        const angle = Math.atan2(dy, dx);
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        px(20*sizeM, -4, 30*sizeM, 8, telegraphColor);
        ctx.restore();
      } else {
        px(x-18*sizeM,y-50*sizeM,36*sizeM,14, telegraphColor);
      }
      ctx.globalAlpha = e.dying ? (e.deathT / 20) : 1;
    }

    // Health bar
    if(e.maxHp > 3){
      const pct = e.hp / e.maxHp;
      const barW = 40 * sizeM;
      const barH = e.role === "BOSS" || e.role === "MINIBOSS" ? 10 : 7;
      const barY = y - 40 * sizeM;

      px(x - barW/2, barY, barW, barH, COLORS.ui.healthBg, 0.9);
      const hpColor = pct > 0.3 ? COLORS.ui.health : COLORS.ui.healthLow;
      px(x - barW/2, barY, barW * pct, barH, hpColor, 0.95);

      ctx.strokeStyle = e.isElite ? COLORS.ui.elite : "#000";
      ctx.lineWidth = e.isElite ? 2 : 1;
      ctx.strokeRect(x - barW/2, barY, barW, barH);
    }

    // Flash on hit
    if(e.flashT>0){
      e.flashT--;
      const alpha = e.dying ? (e.deathT / 20) * 0.35 : 0.35;
      ctx.globalAlpha = alpha;
      const w = 6*S*sizeM;
      px(x-w/2,y-3*S*sizeM,w,9*S*sizeM,"#fff");
      ctx.globalAlpha = e.dying ? (e.deathT / 20) : 1;
    }

    // Restore context if dying
    if(e.dying){
      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }

  function drawArenaBg(){
    // Gradient background
    const grad = ctx.createRadialGradient(WORLD.w/2, WORLD.h/2, 0, WORLD.w/2, WORLD.h/2, 600);
    grad.addColorStop(0, G.isBossRoom ? "#2a1528" : "#1a1528");
    grad.addColorStop(1, G.isBossRoom ? "#1a0511" : "#0a0511");
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,WORLD.w,WORLD.h);

    // Arena circle with glow
    ctx.globalAlpha=0.18;
    ctx.strokeStyle = G.isBossRoom ? "#8a3a5a" : "#4a3a5a";
    ctx.lineWidth=16;
    ctx.beginPath();
    ctx.ellipse(WORLD.w/2,WORLD.h/2,520,320,0,0,Math.PI*2);
    ctx.stroke();

    ctx.globalAlpha=0.12;
    ctx.strokeStyle = G.isBossRoom ? "#aa4a7a" : "#6a4a7a";
    ctx.lineWidth=3;
    for(let i=0;i<14;i++){
      const a=i*0.45+(G.tick*0.001);
      const r=150+(i%5)*45;
      ctx.beginPath();
      ctx.moveTo(WORLD.w/2+Math.cos(a)*r, WORLD.h/2+Math.sin(a)*r*0.7);
      ctx.lineTo(WORLD.w/2+Math.cos(a+0.2)*(r+70), WORLD.h/2+Math.sin(a+0.2)*(r+70)*0.7);
      ctx.stroke();
    }
    ctx.globalAlpha=1;

    // Boundary walls
    const wallGrad = ctx.createLinearGradient(0, 0, 0, 20);
    wallGrad.addColorStop(0, "#1a1a2e");
    wallGrad.addColorStop(1, "#0a0a1a");

    ctx.globalAlpha=0.95;
    ctx.fillStyle = wallGrad;
    ctx.fillRect(0,0,WORLD.w,18);
    ctx.fillRect(0,WORLD.h-18,WORLD.w,18);
    ctx.fillRect(0,0,18,WORLD.h);
    ctx.fillRect(WORLD.w-18,0,18,WORLD.h);
    ctx.globalAlpha=1;

    // Door markers
    const locked = !(G.phase==="CLEAR" || G.phase==="REWARD" || G.phase==="ENTER");
    const col = locked ? COLORS.ui.danger : COLORS.ui.success;
    const glowCol = locked ? "#660000" : "#00aa44";

    ctx.shadowBlur = 10;
    ctx.shadowColor = glowCol;
    px(WORLD.w/2-50, 10, 100, 14, col, 0.9);
    px(WORLD.w/2-50, WORLD.h-24, 100, 14, col, 0.9);
    px(10, WORLD.h/2-50, 14, 100, col, 0.9);
    px(WORLD.w-24, WORLD.h/2-50, 14, 100, col, 0.9);
    ctx.shadowBlur = 0;
  }

  function drawPortals(){
    for(const p of G.portals){
      p.t += 0.06;
      const pulse=0.5+0.5*Math.sin(p.t);

      ctx.shadowBlur = 20;
      ctx.shadowColor = "#aa44ff";
      ctx.globalAlpha=0.40+0.30*pulse;
      px(p.x-24,p.y-24,48,48,"#6f00ff");

      ctx.shadowBlur = 15;
      ctx.globalAlpha=0.30+0.30*pulse;
      px(p.x-14,p.y-14,28,28,"#ff3cff");

      ctx.shadowBlur = 0;
      ctx.globalAlpha=1;
    }
  }

  // CAMERA
  function beginCamera(){
    const camX = G.player ? G.player.x : WORLD.w/2;
    const camY = G.player ? G.player.y : WORLD.h/2;
    let ox=0, oy=0;
    if(G.shake>0){
      G.shake--;
      ox=(rnd()*2-1)*6; oy=(rnd()*2-1)*6;
    }
    const scale=Math.min(canvas.width/1100, canvas.height/700);
    ctx.save();
    ctx.translate(canvas.width/2+ox, canvas.height/2+oy);
    ctx.scale(scale, scale);
    ctx.translate(-camX, -camY);
    return scale;
  }
  function endCamera(){ ctx.restore(); }

  // ===== ENEMY SYSTEM =====
  function spawnEnemy(role, isElite=false){
    const p = choice(G.portals);
    const def = ENEMY_TYPES[role];
    if(!def) return;

    const hpMultiplier = isElite ? 2.0 : 1.0;
    const e = {
      role,
      isElite,
      x: p.x + (rnd()*20-10),
      y: p.y + (rnd()*20-10),
      vx:0, vy:0,
      hp: def.hp * hpMultiplier,
      maxHp: def.hp * hpMultiplier,
      size: def.size,
      speed: def.speed,
      attackRange: def.attackRange,
      attackDamage: def.attackDamage,
      attackCD: def.attackCD,
      windupTime: def.windupTime,
      seed:(rnd()*9999)|0,
      flashT:0,
      state:"MOVE",
      stT:0,
      cdT:0,
      dying: false,
      deathT: 20,
      summonCooldown: 0,
      chargeDir: null
    };

    // Spawn particles
    const cs = COLORS[role.toLowerCase()] || COLORS.grunt;
    addExplosion(e.x, e.y, cs.glow, 8);

    G.enemies.push(e);
  }

  function compForRoom(room){
    const local = mulberry32(hashSeed(G.seedStr + ":" + room));
    function lrnd(){ return local(); }

    // Boss room every 10 rooms
    if(room % 10 === 0){
      return {
        waves: [],
        final: ["BOSS"],
        isBoss: true
      };
    }

    // Mini-boss room every 5 rooms (but not on boss rooms)
    if(room % 5 === 0){
      const support = [];
      const count = 2 + Math.floor(room / 10);
      for(let i=0; i<count; i++){
        const r = lrnd();
        if(room <= 5) support.push("GRUNT");
        else if(room <= 10) support.push(r < 0.5 ? "GRUNT" : "RUNNER");
        else support.push(r < 0.4 ? "SHOOTER" : "RUNNER");
      }
      return {
        waves: [],
        final: ["MINIBOSS", ...support],
        isMiniBoss: true
      };
    }

    function pickRole(){
      const r = lrnd();

      // Rooms 1-3: Basic enemies
      if(room <= 3){
        return r < 0.7 ? "GRUNT" : "RUNNER";
      }

      // Rooms 4-6: Add shooters
      if(room <= 6){
        if(r < 0.45) return "GRUNT";
        if(r < 0.75) return "RUNNER";
        return "SHOOTER";
      }

      // Rooms 7-9: Add tanks and chargers
      if(room <= 9){
        if(r < 0.30) return "GRUNT";
        if(r < 0.50) return "RUNNER";
        if(r < 0.75) return "SHOOTER";
        if(r < 0.90) return "TANK";
        return "CHARGER";
      }

      // Rooms 10+: All enemy types
      if(r < 0.20) return "GRUNT";
      if(r < 0.35) return "RUNNER";
      if(r < 0.50) return "SHOOTER";
      if(r < 0.62) return "TANK";
      if(r < 0.72) return "CHARGER";
      if(r < 0.82) return "SNIPER";
      if(r < 0.92) return "BOMBER";
      return "SUMMONER";
    }

    const waves=[];
    const micro = 2 + (room>=4?1:0) + (room>=8?1:0);
    for(let i=0;i<micro;i++){
      const count = 2 + Math.min(4, Math.floor(room/2)) + (i===micro-1?1:0);
      const roles=[];
      for(let k=0;k<count;k++) roles.push(pickRole());
      waves.push({roles});
    }

    const fcount = 3 + Math.min(5, Math.floor(room/2));
    const final=[];
    for(let k=0;k<fcount;k++){
      let r=pickRole();
      if(room>=12 && lrnd()<0.20) r="TANK";
      final.push(r);
    }

    return {waves, final, isBoss: false, isMiniBoss: false};
  }

  function startRoom(roomNum){
    G.room = roomNum;
    G.enemies.length = 0;
    G.pShots.length = 0;
    G.eShots.length = 0;

    G._comp = compForRoom(G.room);
    G.isBossRoom = G._comp.isBoss || G._comp.isMiniBoss;

    // Set boss tracking
    if(G._comp.isBoss){
      G.bossName = "THE DESTROYER";
      G.bossMaxHP = ENEMY_TYPES.BOSS.hp;
    } else if(G._comp.isMiniBoss){
      G.bossName = "ELITE CHAMPION";
      G.bossMaxHP = ENEMY_TYPES.MINIBOSS.hp;
    }

    G.wave = 0;
    G.toSpawn = 0;
    G.maxOnScreen = Math.min(12, 6 + Math.floor(G.room/3));
    G.phase = "LOCKED";
    G.phaseT = 25;
  }

  function advancePhase(){
    if(G.phase==="ENTER"){
      startRoom(G.room);
      return;
    }
    if(G.phase==="LOCKED"){
      G.phase="WAVE";
      if(G._comp.waves.length > 0){
        G.toSpawn = G._comp.waves[0].roles.length;
      } else {
        G.phase="FINAL";
        G.toSpawn = G._comp.final.length;
      }
      return;
    }
    if(G.phase==="WAVE"){
      if(G.wave < G._comp.waves.length-1){
        G.phase="BREATHER"; G.phaseT=55;
      } else {
        G.phase="FINAL";
        G.toSpawn = G._comp.final.length;
      }
      return;
    }
    if(G.phase==="BREATHER"){
      G.wave++;
      G.phase="WAVE";
      G.toSpawn = G._comp.waves[G.wave].roles.length;
      return;
    }
    if(G.phase==="FINAL"){
      G.phase="CLEAR"; G.phaseT=55;
      return;
    }
    if(G.phase==="CLEAR"){
      G.phase="REWARD";
      G.isBossRoom = false;
      return;
    }
  }

  function generateUpgradeChoices(){
    const pool = ITEM_POOL.filter(it => {
      if(it.id==="cleave_w") return G.player.name==="WARRIOR";
      if(it.id==="pierce") return G.player.name==="ARCHER";
      if(it.id==="burst_r") return G.player.name==="WIZARD";
      return true;
    });
    const local = mulberry32(hashSeed(G.seedStr + ":items:" + G.room));
    function lrnd(){ return local(); }
    const picks=[]; const used=new Set();
    while(picks.length<3 && picks.length<pool.length){
      const it = pool[(lrnd()*pool.length)|0];
      if(used.has(it.id)) continue;
      used.add(it.id); picks.push(it);
    }
    G.upgradeChoices = picks;
  }

  // COMBAT
  function hitFX(power=1){
    G.hitstop = Math.min(7, G.hitstop + (power>=2?2:1));
    G.shake = Math.min(12, G.shake + (power>=2?4:2));
  }
  function critMul(){ return (rnd() < G.mods.critChance) ? 2 : 1; }

  function doAttack(){
    const p = G.player;
    if(p.cdT>0) return;
    p.cdT=p.cd;
    p.atkT=10;

    const aimAng = Math.atan2(p.aimY, p.aimX);

    if(p.name==="WARRIOR"){
      const R=150;
      const arc=(Math.PI*0.8)*G.mods.cleaveArc;
      const center=aimAng;
      for(const e of G.enemies){
        if(e.dying) continue;
        const dx=e.x-p.x, dy=e.y-p.y;
        const d=Math.hypot(dx,dy);
        if(d>R) continue;
        const ang=Math.atan2(dy,dx);
        const diff=Math.atan2(Math.sin(ang-center), Math.cos(ang-center));
        if(Math.abs(diff)<=arc/2){
          const crit = critMul();
          const dmg=2*crit;
          e.hp-=dmg; e.flashT=6;
          addDamageNumber(e.x, e.y, dmg, crit===2);
          addBloodSpray(e.x, e.y, dx/d, dy/d);
          const k=5.0*G.mods.knock;
          e.vx += (dx/d)*k; e.vy += (dy/d)*k;
          hitFX(1);
        }
      }
    } else if(p.name==="ARCHER"){
      const sp=9.0;
      const vx=Math.cos(aimAng)*sp;
      const vy=Math.sin(aimAng)*sp;
      const crit = critMul();
      G.pShots.push({
        kind:"arrow",
        x: p.x + Math.cos(aimAng)*70,
        y: p.y + Math.sin(aimAng)*70 - 12,
        vx, vy,
        life: 140,
        dmg: 2*crit,
        isCrit: crit===2,
        pierce: 1 + G.mods.arrowPierce
      });
    } else { // WIZARD - Fire magic orb volley
      const orbCount = 3 + G.mods.orbCount;
      const spreadAngle = Math.PI / 4; // 45 degree spread
      const sp = 8.0;

      for(let i = 0; i < orbCount; i++) {
        // Calculate angle offset for spread pattern
        const angleOffset = orbCount === 1 ? 0 : (i / (orbCount - 1) - 0.5) * spreadAngle;
        const angle = aimAng + angleOffset;
        const vx = Math.cos(angle) * sp;
        const vy = Math.sin(angle) * sp;
        const crit = critMul();

        G.pShots.push({
          kind: "orb",
          x: p.x + Math.cos(angle) * 60,
          y: p.y + Math.sin(angle) * 60 - 12,
          vx, vy,
          life: 120,
          dmg: 2.5 * crit * G.mods.orbSize,
          isCrit: crit === 2,
          size: G.mods.orbSize
        });
      }
    }
  }

  function updateEnemy(e){
    if(e.dying){
      e.deathT--;
      if(e.deathT <= 0) e.hp = -999;
      return;
    }

    const p=G.player;
    const d=dist(p.x,p.y,e.x,e.y)||1;

    // Separation
    let sepX=0, sepY=0;
    for(const o of G.enemies){
      if(o===e || o.dying) continue;
      const dd=dist(e.x,e.y,o.x,o.y);
      if(dd>0 && dd<72*e.size){ sepX += (e.x-o.x)/dd*0.5; sepY += (e.y-o.y)/dd*0.5; }
    }

    if(e.stT>0) e.stT--;
    if(e.cdT>0) e.cdT--;
    if(e.summonCooldown > 0) e.summonCooldown--;

    const toPX=(p.x-e.x)/d, toPY=(p.y-e.y)/d;

    // Predictive aiming for ranged enemies (lead shots)
    const leadTime = (e.role==="SNIPER")?12:(e.role==="SHOOTER")?8:0;
    const predictX = p.x + p.vx * leadTime;
    const predictY = p.y + p.vy * leadTime;
    const predDist = dist(e.x, e.y, predictX, predictY) || 1;
    const toPredX = (predictX - e.x) / predDist;
    const toPredY = (predictY - e.y) / predDist;

    // ROLE-SPECIFIC AI
    if(e.state==="MOVE"){
      if(e.role==="SHOOTER"){
        const desired=300;
        const push=(d<desired)?-1:1;
        e.vx += toPX*e.speed*push;
        e.vy += toPY*e.speed*push;
        if(e.cdT<=0 && d<e.attackRange){
          e.state="WINDUP"; e.stT=e.windupTime; e._act="SHOOT"; e.cdT=e.attackCD;
        }
      } else if(e.role==="SNIPER"){
        const desired=450;
        const push=(d<desired)?-1:1;
        e.vx += toPX*e.speed*push;
        e.vy += toPY*e.speed*push;
        if(e.cdT<=0 && d<e.attackRange){
          e.state="WINDUP"; e.stT=e.windupTime; e._act="SNIPE"; e.cdT=e.attackCD;
        }
      } else if(e.role==="RUNNER"){
        const sx=-toPY, sy=toPX;
        e.vx += (toPX*0.10 + sx*e.speed);
        e.vy += (toPY*0.10 + sy*e.speed);
        if(e.cdT<=0 && d<e.attackRange){
          e.state="WINDUP"; e.stT=e.windupTime; e._act="DASH"; e.cdT=e.attackCD;
        }
      } else if(e.role==="TANK"){
        e.vx += toPX*e.speed; e.vy += toPY*e.speed;
        if(e.cdT<=0 && d<e.attackRange){
          e.state="WINDUP"; e.stT=e.windupTime; e._act="SLAM"; e.cdT=e.attackCD;
        }
      } else if(e.role==="CHARGER"){
        e.vx += toPX*e.speed; e.vy += toPY*e.speed;
        if(e.cdT<=0 && d<e.attackRange){
          e.state="WINDUP"; e.stT=e.windupTime; e._act="CHARGE"; e.cdT=e.attackCD;
          e.chargeDir = {x: toPX, y: toPY};
        }
      } else if(e.role==="BOMBER"){
        e.vx += toPX*e.speed; e.vy += toPY*e.speed;
        if(d < e.attackRange){
          e.state="WINDUP"; e.stT=e.windupTime; e._act="EXPLODE"; e.cdT=999;
        }
      } else if(e.role==="SUMMONER"){
        const desired=350;
        const push=(d<desired)?-1:1;
        e.vx += toPX*e.speed*push;
        e.vy += toPY*e.speed*push;
        if(e.cdT<=0 && e.summonCooldown<=0){
          e.state="WINDUP"; e.stT=e.windupTime; e._act="SUMMON"; e.cdT=e.attackCD;
        }
      } else if(e.role==="MINIBOSS" || e.role==="BOSS"){
        e.vx += toPX*e.speed; e.vy += toPY*e.speed;
        if(e.cdT<=0){
          // HP-based attack phases for bosses
          const hpPercent = e.hp / e.maxHp;
          let attacks;

          if(e.role === "BOSS"){
            if(hpPercent > 0.66){
              // Phase 1: Basic attacks
              attacks = ["SLAM", "WAVE", "BARRAGE"];
            } else if(hpPercent > 0.33){
              // Phase 2: Harder patterns
              attacks = ["WAVE", "SPIRAL", "BARRAGE", "BARRAGE"];
            } else {
              // Phase 3: ENRAGED - all attacks!
              attacks = ["WAVE", "SPIRAL", "BARRAGE", "SPIRAL", "WAVE"];
            }
          } else {
            // Miniboss has simpler pattern
            attacks = ["SLAM", "WAVE", "BARRAGE"];
          }

          e._act = choice(attacks);
          e.state="WINDUP"; e.stT=e.windupTime; e.cdT=e.attackCD;
        }
      } else { // GRUNT
        e.vx += toPX*e.speed; e.vy += toPY*e.speed;
        if(e.cdT<=0 && d<e.attackRange){
          e.state="WINDUP"; e.stT=e.windupTime; e._act="SWIPE"; e.cdT=e.attackCD;
        }
      }
    } else if(e.state==="WINDUP"){
      e.vx += toPX*0.06; e.vy += toPY*0.06;
      if(e.stT<=0){ e.state="ACT"; e.stT=8; }
    } else if(e.state==="ACT"){
      if(e._act==="SHOOT"){
        if(e.stT===8){
          // Triple shot pattern
          for(let i=-1; i<=1; i++){
            const angle = Math.atan2(toPredY, toPredX) + i * 0.15;
            const vx=Math.cos(angle)*8.5, vy=Math.sin(angle)*8.5;
            G.eShots.push({x:e.x, y:e.y-12, vx, vy, life:120, dmg:e.attackDamage});
          }
        }
      } else if(e._act==="SNIPE"){
        if(e.stT===8){
          // Predictive snipe shot (very fast!)
          const vx=toPredX*11.0, vy=toPredY*11.0;
          G.eShots.push({x:e.x, y:e.y-12, vx, vy, life:150, dmg:e.attackDamage, precise:true});
        }
      } else if(e._act==="DASH"){
        e.vx += toPX*3.2; e.vy += toPY*3.2;
      } else if(e._act==="CHARGE"){
        if(e.chargeDir){
          e.vx += e.chargeDir.x*4.5;
          e.vy += e.chargeDir.y*4.5;
        }
      } else if(e._act==="SLAM"){
        e.vx += toPX*1.8; e.vy += toPY*1.8;
        if(e.stT===8 && d<160*e.size){
          p.hp -= e.attackDamage * G.mods.touchResist;
          p.hurtT=12; hitFX(2);
          // Knockback on slam
          p.vx += toPX * 2;
          p.vy += toPY * 2;
        }
      } else if(e._act==="WAVE"){
        if(e.stT===8){
          // Boss wave attack - MORE bullets
          const count = e.role === "BOSS" ? 16 : 12;
          for(let i=0; i<count; i++){
            const angle = (i/count) * Math.PI * 2 + G.tick * 0.05;
            const vx = Math.cos(angle) * 7;
            const vy = Math.sin(angle) * 7;
            G.eShots.push({x:e.x, y:e.y, vx, vy, life:120, dmg:e.attackDamage * 0.6});
          }
        }
      } else if(e._act==="SPIRAL"){
        // New boss attack: Spiral pattern
        if(e.stT===8 || e.stT===6 || e.stT===4){
          for(let i=0; i<6; i++){
            const angle = (i/6) * Math.PI * 2 + (8-e.stT) * 0.8;
            const vx = Math.cos(angle) * 6.5;
            const vy = Math.sin(angle) * 6.5;
            G.eShots.push({x:e.x, y:e.y, vx, vy, life:110, dmg:e.attackDamage * 0.5});
          }
        }
      } else if(e._act==="BARRAGE"){
        // New boss attack: Aimed barrage
        if(e.stT===8 || e.stT===6 || e.stT===4 || e.stT===2){
          const vx=toPX*8.5, vy=toPY*8.5;
          G.eShots.push({x:e.x, y:e.y, vx, vy, life:100, dmg:e.attackDamage});
        }
      } else if(e._act==="EXPLODE"){
        if(e.stT===8){
          if(d < 220){
            p.hp -= e.attackDamage * G.mods.touchResist;
            p.hurtT=15; hitFX(3);
            p.vx += toPX * -3; // Knockback
            p.vy += toPY * -3;
          }
          const cs = COLORS[e.role.toLowerCase()];
          addExplosion(e.x, e.y, cs.body, 24);
          e.hp = 0;
        }
      } else if(e._act==="SUMMON"){
        if(e.stT===8){
          spawnEnemy("GRUNT");
          spawnEnemy("RUNNER");
          spawnEnemy("GRUNT");
          e.summonCooldown = 150;
        }
      } else if(e._act==="SWIPE"){
        if(e.stT===8 && d<140*e.size){
          p.hp -= e.attackDamage * G.mods.touchResist;
          p.hurtT=10; hitFX(1);
        }
      }
      if(e.stT<=0){
        e.state="RECOVER";
        e.stT = (e.role==="TANK" || e.role==="BOSS" || e.role==="MINIBOSS")?10:6;
      }
    } else if(e.state==="RECOVER"){
      e.vx*=0.92; e.vy*=0.92;
      if(e.stT<=0){ e.state="MOVE"; }
    }

    e.vx += sepX*0.35; e.vy += sepY*0.35;
    e.vx*=0.86; e.vy*=0.86;
    e.x += e.vx; e.y += e.vy;
    e.x = clamp(e.x,60,WORLD.w-60);
    e.y = clamp(e.y,60,WORLD.h-60);

    // Increased touch damage (punish face-tanking)
    if(d<78*e.size){
      const chip = e.attackDamage * 0.08;
      p.hp -= chip * G.mods.touchResist;
      p.hurtT=5;
      p.vx += (p.x-e.x)/d*0.06;
      p.vy += (p.y-e.y)/d*0.06;
    }
  }

  // MENU / UPGRADE state
  const seedPresets=["duck-1","gauntlet-77","arena-2025","rng-42","bosssoon"];
  let seedIndex=0;
  let upgradePick=0;

  // HUD helpers
  function wrapText(text,x,y,maxWidth,lineHeight){
    const words=text.split(" ");
    let line="";
    for(let n=0;n<words.length;n++){
      const test=line+words[n]+" ";
      if(ctx.measureText(test).width>maxWidth && n>0){
        ctx.fillText(line,x,y);
        line=words[n]+" ";
        y+=lineHeight;
      } else line=test;
    }
    ctx.fillText(line,x,y);
  }

  function drawBossBar(){
    if(!G.isBossRoom) return;

    const boss = G.enemies.find(e => e.role === "BOSS" || e.role === "MINIBOSS");
    if(!boss || boss.dying) return;

    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);

    const barW = 600;
    const barH = 24;
    const x = canvas.width/2 - barW/2;
    const y = 20;

    // Background
    px(x-4, y-4, barW+8, barH+8, COLORS.ui.panel, 0.9);
    ctx.strokeStyle = boss.role === "BOSS" ? COLORS.ui.boss : COLORS.ui.elite;
    ctx.lineWidth = 3;
    ctx.strokeRect(x-4, y-4, barW+8, barH+8);

    // HP bar
    const pct = boss.hp / boss.maxHp;
    px(x, y, barW, barH, COLORS.ui.healthBg, 0.9);

    const hpColor = boss.role === "BOSS" ? COLORS.ui.boss : COLORS.ui.elite;
    px(x, y, barW * pct, barH, hpColor, 0.95);

    // Name
    ctx.fillStyle = COLORS.ui.textBright;
    ctx.font = "bold 16px monospace";
    ctx.textAlign = "center";
    ctx.fillText(G.bossName, canvas.width/2, y + 18);

    // HP text
    ctx.font = "12px monospace";
    ctx.fillText(`${Math.floor(boss.hp)} / ${boss.maxHp}`, canvas.width/2, y + barH + 18);
    ctx.textAlign = "left";

    ctx.restore();
  }

  function drawHUD(){
    ctx.save(); ctx.setTransform(1,0,0,1,0,0);
    const pad=16;

    // Panel background with border
    const panelGrad = ctx.createLinearGradient(0, 0, 0, 100);
    panelGrad.addColorStop(0, COLORS.ui.panel);
    panelGrad.addColorStop(1, COLORS.ui.bg);
    ctx.fillStyle = panelGrad;
    ctx.globalAlpha = 0.85;
    ctx.fillRect(pad, pad, 400, 90);
    ctx.globalAlpha = 1;

    ctx.strokeStyle = COLORS.ui.border;
    ctx.lineWidth = 2;
    ctx.strokeRect(pad, pad, 400, 90);

    // Smooth HP animation
    G.targetHP = Math.max(0, G.player.hp);
    G.displayHP += (G.targetHP - G.displayHP) * 0.15;

    const hpPct = G.displayHP / G.player.max;
    const isLowHP = hpPct < 0.3;

    // HP bar background
    px(pad+16, pad+18, 250, 16, COLORS.ui.healthBg, 0.9);

    // HP bar
    const hpColor = isLowHP ? COLORS.ui.healthLow : COLORS.ui.health;
    px(pad+16, pad+18, 250 * hpPct, 16, hpColor, 0.95);

    // Low HP warning
    if(isLowHP && (G.tick % 30) < 15){
      ctx.shadowBlur = 8;
      ctx.shadowColor = COLORS.ui.healthLow;
      px(pad+16, pad+18, 250 * hpPct, 16, COLORS.ui.healthLow, 0.6);
      ctx.shadowBlur = 0;
    }

    // HP bar border
    ctx.strokeStyle = COLORS.ui.border;
    ctx.lineWidth = 2;
    ctx.strokeRect(pad+16, pad+18, 250, 16);

    // Text
    ctx.fillStyle = COLORS.ui.text;
    ctx.font = "bold 16px monospace";
    ctx.fillText(G.player.name, pad+16, pad+52);

    ctx.font = "14px monospace";
    ctx.fillText(`HP ${Math.floor(G.displayHP)}/${G.player.max}`, pad+16, pad+72);

    // Score
    ctx.fillStyle = COLORS.ui.gold;
    ctx.font = "bold 14px monospace";
    ctx.fillText("â­ " + G.score, pad+160, pad+72);

    // Room info
    ctx.fillStyle = COLORS.ui.success;
    ctx.font = "14px monospace";
    const roomText = G.isBossRoom ? `Room ${G.room} â€¢ BOSS!` : `Room ${G.room} â€¢ ${G.phase}`;
    ctx.fillText(roomText, pad+160, pad+52);

    // Wave progress
    if(G.phase === "WAVE" || G.phase === "FINAL"){
      const totalEnemies = G.phase === "WAVE" ? G._comp.waves[G.wave].roles.length : G._comp.final.length;
      const remaining = G.toSpawn + G.enemies.filter(e => !e.dying).length;
      const progress = 1 - (remaining / totalEnemies);

      px(pad+16, pad+88, 250, 6, COLORS.ui.healthBg, 0.7);
      px(pad+16, pad+88, 250 * progress, 6, COLORS.ui.warning, 0.9);
    }

    // Controls
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = COLORS.ui.textDim;
    ctx.font = "13px monospace";
    ctx.fillText("Move: â† â†’ â†‘ â†“  |  Attack: SPACE (4-way)", pad, canvas.height-16);
    ctx.fillStyle = COLORS.ui.textBright;
    ctx.fillText(`Seed: ${G.seedStr}  |  Kills: ${G.kills}`, pad, canvas.height-36);
    ctx.globalAlpha = 1;
    ctx.restore();

    // Boss bar
    drawBossBar();
  }

  function drawLogo(x, y, scale=1){
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);

    ctx.shadowBlur = 25;
    ctx.shadowColor = COLORS.ui.success;
    ctx.fillStyle = COLORS.ui.success;
    ctx.font = "bold 64px monospace";
    ctx.fillText("ARENA", -130, 10);

    ctx.shadowBlur = 0;

    ctx.globalAlpha = 0.6;
    ctx.fillStyle = COLORS.ui.textDim;
    ctx.font = "12px monospace";
    ctx.fillText("v13.0 Boss Update", -80, 35);
    ctx.globalAlpha = 1;

    ctx.restore();
  }

  function drawMenu(){
    const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.height);
    grad.addColorStop(0, "#1a1528");
    grad.addColorStop(1, "#0a0511");
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    for(let i=0; i<20; i++){
      const x = (canvas.width/2) + Math.cos(G.tick*0.01 + i*0.5) * (200 + i*20);
      const y = (canvas.height/3) + Math.sin(G.tick*0.01 + i*0.3) * (100 + i*15);
      ctx.globalAlpha = 0.1 + 0.05 * Math.sin(G.tick*0.02 + i);
      px(x, y, 4, 4, COLORS.ui.success);
    }
    ctx.globalAlpha = 1;

    drawLogo(canvas.width/2, canvas.height/3);

    ctx.fillStyle = COLORS.ui.textDim;
    ctx.font = "16px monospace";
    const controlY = canvas.height/3 + 90;
    ctx.fillText("â† â†’ Class  â€¢  â†‘ â†“ Seed  â€¢  SPACE Start", canvas.width/2 - 200, controlY);

    const cy = canvas.height/2 + 40;
    const panelW = 600;
    const panelH = 180;
    const panelX = canvas.width/2 - panelW/2;
    const panelY = cy - 40;

    ctx.fillStyle = COLORS.ui.panel;
    ctx.globalAlpha = 0.7;
    ctx.fillRect(panelX, panelY, panelW, panelH);
    ctx.globalAlpha = 1;

    ctx.strokeStyle = COLORS.ui.borderActive;
    ctx.lineWidth = 3;
    ctx.strokeRect(panelX, panelY, panelW, panelH);

    const cls = CLASSES[pick];
    const colorScheme = (cls.name==="WARRIOR") ? COLORS.warrior : (cls.name==="ARCHER") ? COLORS.archer : COLORS.wizard;

    ctx.fillStyle = colorScheme.primary;
    ctx.font = "bold 28px monospace";
    ctx.fillText(cls.name, panelX + 30, panelY + 45);

    ctx.fillStyle = COLORS.ui.textDim;
    ctx.font = "16px monospace";
    ctx.fillText(cls.desc, panelX + 30, panelY + 75);

    ctx.fillStyle = COLORS.ui.text;
    ctx.font = "14px monospace";
    ctx.fillText(`â™¥ HP: ${cls.hp}`, panelX + 30, panelY + 105);
    ctx.fillText(`âš¡ Speed: ${cls.speed}`, panelX + 150, panelY + 105);
    ctx.fillText(`âš” Cooldown: ${cls.cd}f`, panelX + 280, panelY + 105);

    ctx.fillStyle = COLORS.ui.gold;
    ctx.font = "24px monospace";
    ctx.fillText("â—€", panelX - 40, panelY + 40);
    ctx.fillText("â–¶", panelX + panelW + 20, panelY + 40);

    const seedY = panelY + panelH + 40;
    ctx.fillStyle = COLORS.ui.text;
    ctx.font = "18px monospace";
    ctx.fillText("Seed:", canvas.width/2 - 180, seedY);

    ctx.fillStyle = COLORS.ui.gold;
    ctx.font = "bold 20px monospace";
    ctx.fillText(seedPresets[seedIndex], canvas.width/2 - 100, seedY);

    ctx.fillStyle = COLORS.ui.textDim;
    ctx.font = "13px monospace";
    ctx.fillText("(Deterministic runs â€¢ Bosses every 10 rooms)", canvas.width/2 - 180, seedY + 25);
  }

  function drawUpgrade(){
    drawWorld();
    ctx.save(); ctx.setTransform(1,0,0,1,0,0);

    ctx.fillStyle = COLORS.ui.bgOverlay;
    ctx.globalAlpha = 0.85;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 1;

    const cx = canvas.width/2;

    ctx.shadowBlur = 15;
    ctx.shadowColor = COLORS.ui.gold;
    ctx.fillStyle = COLORS.ui.gold;
    ctx.font = "bold 32px monospace";
    ctx.fillText("â¬† CHOOSE UPGRADE â¬†", cx - 200, 100);
    ctx.shadowBlur = 0;

    ctx.fillStyle = COLORS.ui.textDim;
    ctx.font = "16px monospace";
    ctx.fillText("â† â†’ Select  â€¢  SPACE Confirm", cx - 140, 140);

    const cardW = 280;
    const cardH = 200;
    const gap = 30;
    const startX = cx - (cardW * G.upgradeChoices.length + gap * (G.upgradeChoices.length - 1)) / 2;

    for(let i = 0; i < G.upgradeChoices.length; i++){
      const it = G.upgradeChoices[i];
      const x = startX + i * (cardW + gap);
      const y = 180;
      const isSelected = i === upgradePick;

      const cardGrad = ctx.createLinearGradient(x, y, x, y + cardH);
      cardGrad.addColorStop(0, COLORS.ui.panel);
      cardGrad.addColorStop(1, COLORS.ui.bg);
      ctx.fillStyle = cardGrad;
      ctx.globalAlpha = isSelected ? 0.95 : 0.7;
      ctx.fillRect(x, y, cardW, cardH);
      ctx.globalAlpha = 1;

      let borderColor = COLORS.ui.border;
      if(it.rarity === "epic") borderColor = "#b066ff";
      else if(it.rarity === "rare") borderColor = "#44d9ff";
      else borderColor = "#888888";

      if(isSelected){
        ctx.shadowBlur = 15;
        ctx.shadowColor = COLORS.ui.gold;
      }
      ctx.strokeStyle = isSelected ? COLORS.ui.borderActive : borderColor;
      ctx.lineWidth = isSelected ? 4 : 3;
      ctx.strokeRect(x, y, cardW, cardH);
      ctx.shadowBlur = 0;

      ctx.fillStyle = borderColor;
      ctx.globalAlpha = 0.3;
      ctx.fillRect(x, y, cardW, 8);
      ctx.globalAlpha = 1;

      ctx.fillStyle = COLORS.ui.gold;
      ctx.font = "48px monospace";
      ctx.fillText(it.icon, x + cardW/2 - 20, y + 65);

      ctx.fillStyle = COLORS.ui.textBright;
      ctx.font = "bold 18px monospace";
      ctx.fillText(it.name, x + 20, y + 110);

      ctx.fillStyle = COLORS.ui.textDim;
      ctx.font = "14px monospace";
      wrapText(it.desc, x + 20, y + 140, cardW - 40, 20);

      ctx.fillStyle = borderColor;
      ctx.font = "11px monospace";
      ctx.fillText(it.rarity.toUpperCase(), x + 20, y + 190);
    }

    ctx.restore();
  }

  function drawGameOver(){
    drawWorld();
    ctx.save(); ctx.setTransform(1,0,0,1,0,0);

    ctx.fillStyle = COLORS.ui.bgOverlay;
    ctx.globalAlpha = 0.80;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 1;

    const cx = canvas.width / 2;
    const cy = canvas.height / 2;

    const blink = ((G.tick / 20) | 0) % 2 === 0;
    if(blink){
      ctx.shadowBlur = 25;
      ctx.shadowColor = COLORS.ui.danger;
      ctx.fillStyle = COLORS.ui.danger;
      ctx.font = "bold 56px monospace";
      ctx.fillText("GAME OVER", cx - 180, cy - 80);
      ctx.shadowBlur = 0;
    }

    const panelW = 400;
    const panelH = 240;
    const panelX = cx - panelW/2;
    const panelY = cy - 20;

    ctx.fillStyle = COLORS.ui.panel;
    ctx.globalAlpha = 0.9;
    ctx.fillRect(panelX, panelY, panelW, panelH);
    ctx.globalAlpha = 1;

    ctx.strokeStyle = COLORS.ui.border;
    ctx.lineWidth = 3;
    ctx.strokeRect(panelX, panelY, panelW, panelH);

    ctx.fillStyle = COLORS.ui.text;
    ctx.font = "bold 24px monospace";
    ctx.fillText("FINAL STATS", panelX + 110, panelY + 40);

    ctx.font = "18px monospace";
    ctx.fillStyle = COLORS.ui.gold;
    ctx.fillText(`â­ Score: ${G.score}`, panelX + 40, panelY + 80);

    ctx.fillStyle = COLORS.ui.text;
    ctx.fillText(`ðŸ’€ Kills: ${G.kills}`, panelX + 40, panelY + 110);
    ctx.fillText(`ðŸšª Rooms: ${G.room}`, panelX + 40, panelY + 140);
    ctx.fillText(`â¬† Upgrades: ${G.upgradesTaken.length}`, panelX + 40, panelY + 170);

    ctx.fillStyle = COLORS.ui.success;
    ctx.font = "bold 18px monospace";
    ctx.fillText("Press SPACE to return to menu", panelX + 40, panelY + 215);

    ctx.restore();
  }

  function drawWorld(){
    beginCamera();
    drawArenaBg();
    drawPortals();
    drawParticles();

    for(const b of G.eShots){
      const shotColor = b.precise ? "#dd88ff" : "#ff88ff";
      ctx.shadowBlur = 8;
      ctx.shadowColor = shotColor;
      px(b.x-6,b.y-6,12,12,shotColor,0.9);
      px(b.x-2,b.y-2,4,4,"#ffd1f5",0.9);
      ctx.shadowBlur = 0;
    }

    for(const s of G.pShots){
      if(s.kind==="arrow"){
        const arrowColor = s.isCrit ? COLORS.ui.gold : "#e6edf3";
        if(s.isCrit){
          ctx.shadowBlur = 10;
          ctx.shadowColor = COLORS.ui.gold;
        }
        px(s.x-22,s.y-5,44,10, arrowColor, 0.95);
        px(s.x+(s.vx>0?14:-18), s.y-12, 10, 24, arrowColor, 0.8);
        ctx.shadowBlur = 0;
      } else if(s.kind==="orb"){
        const orbColor = s.isCrit ? COLORS.ui.gold : COLORS.wizard.primary;
        const pulseSize = 12 * s.size * (1 + 0.15 * Math.sin(G.tick / 3));

        // Outer glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = orbColor;
        ctx.globalAlpha = 0.4;
        px(s.x - pulseSize, s.y - pulseSize, pulseSize * 2, pulseSize * 2, orbColor);

        // Core orb
        ctx.globalAlpha = 0.9;
        ctx.shadowBlur = 8;
        px(s.x - 8 * s.size, s.y - 8 * s.size, 16 * s.size, 16 * s.size, orbColor);

        // Bright center
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        px(s.x - 4 * s.size, s.y - 4 * s.size, 8 * s.size, 8 * s.size, COLORS.wizard.secondary);

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }
    }

    for(const e of G.enemies){
      if(!e.dying || e.deathT > 0) drawEnemy(e);
    }

    if(G.player){
      if(G.player.hurtT>0){
        ctx.globalAlpha=0.25;
        px(G.player.x-50,G.player.y-70,100,140,"#fff");
        ctx.globalAlpha=1;
      }
      drawHero(G.player);
    }

    if(G.player && G.player.name==="WARRIOR" && G.player.atkT>0){
      const a=G.player.atkT/10;
      const center=Math.atan2(G.player.aimY,G.player.aimX);
      const arc=0.8*G.mods.cleaveArc;
      ctx.globalAlpha=0.30*a;
      ctx.strokeStyle = COLORS.warrior.primary;
      ctx.lineWidth=14;
      ctx.beginPath();
      ctx.arc(G.player.x,G.player.y,130,center-arc,center+arc);
      ctx.stroke();
      ctx.globalAlpha=1;
    }

    drawDamageNumbers();
    endCamera();
    drawHUD();
  }

  // UPDATE
  function update(){
    if(G.hitstop>0){ G.hitstop--; return; }
    G.tick++;

    if(state===STATE.MENU){
      if(use("ArrowLeft")) pick=(pick+CLASSES.length-1)%CLASSES.length;
      if(use("ArrowRight")) pick=(pick+1)%CLASSES.length;
      if(use("ArrowUp")) seedIndex=(seedIndex+seedPresets.length-1)%seedPresets.length;
      if(use("ArrowDown")) seedIndex=(seedIndex+1)%seedPresets.length;
      if(use(" ")){ resetRun(CLASSES[pick], seedPresets[seedIndex]); state=STATE.PLAY; }
      return;
    }
    if(state===STATE.OVER){ if(use(" ")) state=STATE.MENU; return; }
    if(state===STATE.UPGRADE){
      if(use("ArrowLeft")) upgradePick=(upgradePick+G.upgradeChoices.length-1)%G.upgradeChoices.length;
      if(use("ArrowRight")) upgradePick=(upgradePick+1)%G.upgradeChoices.length;
      if(use(" ")){
        const it=G.upgradeChoices[upgradePick];
        it.apply(G);
        G.upgradesTaken.push(it.id);
        state=STATE.PLAY;
        G.phase="ENTER"; G.phaseT=20;
        G.room = G.room + 1;
        startRoom(G.room);
      }
      return;
    }

    // PLAY
    const p=G.player;

    if(G.phaseT>0) G.phaseT--;
    if((G.phase==="ENTER" && G.phaseT<=0) || (G.phase==="LOCKED" && G.phaseT<=0) || (G.phase==="CLEAR" && G.phaseT<=0)){
      advancePhase();
    }

    // Spawning
    if(G.phase==="WAVE"){
      const roles=G._comp.waves[G.wave].roles;
      if(G.toSpawn>0 && G.enemies.filter(e => !e.dying).length<G.maxOnScreen && (G.tick%18===0)){
        const role=roles[roles.length-G.toSpawn];
        const isElite = rnd() < 0.15; // 15% chance for elite
        spawnEnemy(role, isElite);
        G.toSpawn--;
      }
      if(G.toSpawn<=0 && G.enemies.filter(e => !e.dying).length===0) advancePhase();
    }
    if(G.phase==="BREATHER"){
      if(G.phaseT<=0) advancePhase();
    }
    if(G.phase==="FINAL"){
      if(G.toSpawn>0 && G.enemies.filter(e => !e.dying).length<G.maxOnScreen && (G.tick%16===0)){
        const role=G._comp.final[G._comp.final.length-G.toSpawn];
        const isElite = (role === "BOSS" || role === "MINIBOSS") ? false : rnd() < 0.20;
        spawnEnemy(role, isElite);
        G.toSpawn--;
      }
      if(G.toSpawn<=0 && G.enemies.filter(e => !e.dying).length===0) advancePhase();
    }

    // Movement
    let ax=0, ay=0;
    let aimX=0, aimY=0;
    if(keys.ArrowLeft){ ax-=p.accel; aimX-=1; }
    if(keys.ArrowRight){ ax+=p.accel; aimX+=1; }
    if(keys.ArrowUp){ ay-=p.accel; aimY-=1; }
    if(keys.ArrowDown){ ay+=p.accel; aimY+=1; }

    if(aimX!==0 || aimY!==0){
      const m=Math.hypot(aimX,aimY);
      p.aimX = aimX/m;
      p.aimY = aimY/m;
      if(Math.abs(p.aimX) > 0.3) p.facing = (p.aimX>=0)?1:-1;
    }

    p.vx=(p.vx+ax)*p.drag;
    p.vy=(p.vy+ay)*p.drag;

    const sp=Math.hypot(p.vx,p.vy);
    if(sp>p.speed){ p.vx=(p.vx/sp)*p.speed; p.vy=(p.vy/sp)*p.speed; }

    p.x += p.vx*6; p.y += p.vy*6;
    if(Math.abs(p.vx)+Math.abs(p.vy)>0.08) p.step++;
    p.x=clamp(p.x,60,WORLD.w-60); p.y=clamp(p.y,60,WORLD.h-60);

    if(use(" ")) doAttack();
    if(p.cdT>0) p.cdT--;
    if(p.atkT>0) p.atkT--;
    if(p.hurtT>0) p.hurtT--;

    for(const e of G.enemies) updateEnemy(e);

    updateParticles();
    updateDamageNumbers();

    // Enemy bullets
    for(const b of G.eShots){
      b.x+=b.vx; b.y+=b.vy; b.life--;
      if(dist(p.x,p.y,b.x,b.y)<70){
        p.hp -= (b.dmg || 9) * G.mods.touchResist;
        p.hurtT=12;
        b.life=0;
        hitFX(2);
      }
    }
    G.eShots = G.eShots.filter(b=>b.life>0);

    // Player shots
    for(const s of G.pShots){
      if(s.kind==="arrow"){
        s.x+=s.vx; s.y+=s.vy; s.life--;
        for(const e of G.enemies){
          if(e.hp<=0 || e.dying) continue;
          if(dist(s.x,s.y,e.x,e.y)<75){
            e.hp -= s.dmg;
            e.flashT=6;
            addDamageNumber(e.x, e.y, s.dmg, s.isCrit);
            const d=dist(s.x,s.y,e.x,e.y)||1;
            const dx = s.vx/d, dy = s.vy/d;
            addBloodSpray(e.x, e.y, dx, dy);
            e.vx += dx*4.5*G.mods.knock;
            e.vy += dy*4.5*G.mods.knock;
            hitFX(1);
            s.pierce--;
            if(s.pierce<0){ s.life=0; break; }
          }
        }
      } else if(s.kind==="orb"){
        s.x+=s.vx; s.y+=s.vy; s.life--;
        for(const e of G.enemies){
          if(e.hp<=0 || e.dying) continue;
          const hitRadius = 60 * s.size;
          if(dist(s.x,s.y,e.x,e.y) < hitRadius){
            e.hp -= s.dmg;
            e.flashT=8;
            addDamageNumber(e.x, e.y, s.dmg, s.isCrit);
            const d=dist(s.x,s.y,e.x,e.y)||1;
            const dx = (e.x-s.x)/d, dy = (e.y-s.y)/d;
            addBloodSpray(e.x, e.y, dx, dy);
            e.vx += dx*3.0*G.mods.knock;
            e.vy += dy*3.0*G.mods.knock;

            // Magic explosion effect
            addExplosion(s.x, s.y, COLORS.wizard.primary, 12 * s.size);

            hitFX(2);
            s.life=0;
            break;
          }
        }
      }
    }
    G.pShots = G.pShots.filter(s=>s.life>0 && ((s.kind!=="arrow" && s.kind!=="orb") || (s.x>-260 && s.x<WORLD.w+260 && s.y>-260 && s.y<WORLD.h+260)));

    // Cull + score
    const alive=[];
    for(const e of G.enemies){
      if(e.hp > 0){
        alive.push(e);
      } else if(!e.dying){
        e.dying = true;
        e.deathT = 20;
        const colorScheme = COLORS[e.role.toLowerCase()] || COLORS.grunt;
        const explosionSize = e.role === "BOSS" ? 48 : e.role === "MINIBOSS" ? 32 : e.isElite ? 20 : 16;
        addExplosion(e.x, e.y, colorScheme.body, explosionSize);

        const def = ENEMY_TYPES[e.role];
        const scoreMultiplier = e.isElite ? 2 : 1;
        G.score += def.score * scoreMultiplier;
        G.kills++;
        alive.push(e);
      } else if(e.deathT > 0){
        alive.push(e);
      }
    }
    G.enemies=alive;

    // Reward transition
    if(G.phase==="REWARD"){
      if(!G._healedThisRoom){
        G._healedThisRoom=true;
        if(G.mods.healOnClear>0) p.hp = Math.min(p.max, p.hp + G.mods.healOnClear);
      }
      const nearDoor = (p.y<70)||(p.y>WORLD.h-70)||(p.x<70)||(p.x>WORLD.w-70);
      if(nearDoor){
        generateUpgradeChoices();
        upgradePick=0;
        state=STATE.UPGRADE;
      }
    } else {
      G._healedThisRoom=false;
    }

    if(p.hp<=0) state=STATE.OVER;
  }

  // MAIN LOOP
  function loop(){
    update();
    if(state===STATE.MENU) drawMenu();
    else if(state===STATE.PLAY) drawWorld();
    else if(state===STATE.UPGRADE) drawUpgrade();
    else drawGameOver();

    for(const k in just) just[k]=false;
    requestAnimationFrame(loop);
  }
  loop();
})();
</script>
</body>
</html>
